import { ElementRef, EventEmitter, OnInit, QueryList, AfterViewInit, DoCheck, KeyValueDiffers, KeyValueDiffer, ChangeDetectorRef } from '@angular/core';
import { DatatableGroupHeaderDirective } from './body/body-group-header.directive';
import { BehaviorSubject, Subscription } from 'rxjs';
import { INgxDatatableConfig } from '../ngx-datatable.module';
import { TableColumn } from '../types/table-column.type';
import { ColumnMode } from '../types/column-mode.type';
import { SelectionType } from '../types/selection.type';
import { SortType } from '../types/sort.type';
import { ContextmenuType } from '../types/contextmenu.type';
import { DataTableColumnDirective } from './columns/column.directive';
import { DatatableRowDetailDirective } from './row-detail/row-detail.directive';
import { DatatableFooterDirective } from './footer/footer.directive';
import { DataTableBodyComponent } from './body/body.component';
import { DataTableHeaderComponent } from './header/header.component';
import { ScrollbarHelper } from '../services/scrollbar-helper.service';
import { ColumnChangesService } from '../services/column-changes.service';
import { DimensionsHelper } from '../services/dimensions-helper.service';
import * as ɵngcc0 from '@angular/core';
export declare class DatatableComponent implements OnInit, DoCheck, AfterViewInit {
    private scrollbarHelper;
    private dimensionsHelper;
    private cd;
    private columnChangesService;
    private configuration;
    /**
     * Template for the target marker of drag target columns.
     */
    targetMarkerTemplate: any;
    /**
     * Rows that are displayed in the table.
     */
    set rows(val: any);
    /**
     * Gets the rows.
     */
    get rows(): any;
    /**
     * This attribute allows the user to set the name of the column to group the data with
     */
    set groupRowsBy(val: string);
    get groupRowsBy(): string;
    /**
     * This attribute allows the user to set a grouped array in the following format:
     *  [
     *    {groupid=1} [
     *      {id=1 name="test1"},
     *      {id=2 name="test2"},
     *      {id=3 name="test3"}
     *    ]},
     *    {groupid=2>[
     *      {id=4 name="test4"},
     *      {id=5 name="test5"},
     *      {id=6 name="test6"}
     *    ]}
     *  ]
     */
    groupedRows: any[];
    /**
     * Columns to be displayed.
     */
    set columns(val: TableColumn[]);
    /**
     * Get the columns.
     */
    get columns(): TableColumn[];
    /**
     * List of row objects that should be
     * represented as selected in the grid.
     * Default value: `[]`
     */
    selected: any[];
    /**
     * Enable vertical scrollbars
     */
    scrollbarV: boolean;
    /**
     * Enable horz scrollbars
     */
    scrollbarH: boolean;
    /**
     * The row height; which is necessary
     * to calculate the height for the lazy rendering.
     */
    rowHeight: number | 'auto' | ((row?: any) => number);
    /**
     * Type of column width distribution formula.
     * Example: flex, force, standard
     */
    columnMode: ColumnMode | keyof typeof ColumnMode;
    /**
     * The minimum header height in pixels.
     * Pass a falsey for no header
     */
    headerHeight: number;
    /**
     * The minimum footer height in pixels.
     * Pass falsey for no footer
     */
    footerHeight: number;
    /**
     * If the table should use external paging
     * otherwise its assumed that all data is preloaded.
     */
    externalPaging: boolean;
    /**
     * If the table should use external sorting or
     * the built-in basic sorting.
     */
    externalSorting: boolean;
    /**
     * The page size to be shown.
     * Default value: `undefined`
     */
    set limit(val: number | undefined);
    /**
     * Gets the limit.
     */
    get limit(): number | undefined;
    /**
     * The total count of all rows.
     * Default value: `0`
     */
    set count(val: number);
    /**
     * Gets the count.
     */
    get count(): number;
    /**
     * The current offset ( page - 1 ) shown.
     * Default value: `0`
     */
    set offset(val: number);
    get offset(): number;
    /**
     * Show the linear loading bar.
     * Default value: `false`
     */
    loadingIndicator: boolean;
    /**
     * Type of row selection. Options are:
     *
     *  - `single`
     *  - `multi`
     *  - `checkbox`
     *  - `multiClick`
     *  - `cell`
     *
     * For no selection pass a `falsey`.
     * Default value: `undefined`
     */
    selectionType: SelectionType;
    /**
     * Enable/Disable ability to re-order columns
     * by dragging them.
     */
    reorderable: boolean;
    /**
     * Swap columns on re-order columns or
     * move them.
     */
    swapColumns: boolean;
    /**
     * The type of sorting
     */
    sortType: SortType;
    /**
     * Array of sorted columns by property and type.
     * Default value: `[]`
     */
    sorts: any[];
    /**
     * Css class overrides
     */
    cssClasses: any;
    /**
     * Message overrides for localization
     *
     * emptyMessage     [default] = 'No data to display'
     * totalMessage     [default] = 'total'
     * selectedMessage  [default] = 'selected'
     */
    messages: any;
    /**
     * Row specific classes.
     * Similar implementation to ngClass.
     *
     *  [rowClass]="'first second'"
     *  [rowClass]="{ 'first': true, 'second': true, 'third': false }"
     */
    rowClass: any;
    /**
     * A boolean/function you can use to check whether you want
     * to select a particular row based on a criteria. Example:
     *
     *    (selection) => {
     *      return selection !== 'Ethel Price';
     *    }
     */
    selectCheck: any;
    /**
     * A function you can use to check whether you want
     * to show the checkbox for a particular row based on a criteria. Example:
     *
     *    (row, column, value) => {
     *      return row.name !== 'Ethel Price';
     *    }
     */
    displayCheck: (row: any, column?: any, value?: any) => boolean;
    /**
     * A boolean you can use to set the detault behaviour of rows and groups
     * whether they will start expanded or not. If ommited the default is NOT expanded.
     *
     */
    groupExpansionDefault: boolean;
    /**
     * Property to which you can use for custom tracking of rows.
     * Example: 'name'
     */
    trackByProp: string;
    /**
     * Property to which you can use for determining select all
     * rows on current page or not.
     *
     * @memberOf DatatableComponent
     */
    selectAllRowsOnPage: boolean;
    /**
     * A flag for row virtualization on / off
     */
    virtualization: boolean;
    /**
     * Tree from relation
     */
    treeFromRelation: string;
    /**
     * Tree to relation
     */
    treeToRelation: string;
    /**
     * A flag for switching summary row on / off
     */
    summaryRow: boolean;
    /**
     * A height of summary row
     */
    summaryHeight: number;
    /**
     * A property holds a summary row position: top/bottom
     */
    summaryPosition: string;
    /**
     * Body was scrolled typically in a `scrollbarV:true` scenario.
     */
    scroll: EventEmitter<any>;
    /**
     * A cell or row was focused via keyboard or mouse click.
     */
    activate: EventEmitter<any>;
    /**
     * A cell or row was selected.
     */
    select: EventEmitter<any>;
    /**
     * Column sort was invoked.
     */
    sort: EventEmitter<any>;
    /**
     * The table was paged either triggered by the pager or the body scroll.
     */
    page: EventEmitter<any>;
    /**
     * Columns were re-ordered.
     */
    reorder: EventEmitter<any>;
    /**
     * Column was resized.
     */
    resize: EventEmitter<any>;
    /**
     * The context menu was invoked on the table.
     * type indicates whether the header or the body was clicked.
     * content contains either the column or the row that was clicked.
     */
    tableContextmenu: EventEmitter<{
        event: MouseEvent;
        type: ContextmenuType;
        content: any;
    }>;
    /**
     * A row was expanded ot collapsed for tree
     */
    treeAction: EventEmitter<any>;
    /**
     * CSS class applied if the header height if fixed height.
     */
    get isFixedHeader(): boolean;
    /**
     * CSS class applied to the root element if
     * the row heights are fixed heights.
     */
    get isFixedRow(): boolean;
    /**
     * CSS class applied to root element if
     * vertical scrolling is enabled.
     */
    get isVertScroll(): boolean;
    /**
     * CSS class applied to root element if
     * virtualization is enabled.
     */
    get isVirtualized(): boolean;
    /**
     * CSS class applied to the root element
     * if the horziontal scrolling is enabled.
     */
    get isHorScroll(): boolean;
    /**
     * CSS class applied to root element is selectable.
     */
    get isSelectable(): boolean;
    /**
     * CSS class applied to root is checkbox selection.
     */
    get isCheckboxSelection(): boolean;
    /**
     * CSS class applied to root if cell selection.
     */
    get isCellSelection(): boolean;
    /**
     * CSS class applied to root if single select.
     */
    get isSingleSelection(): boolean;
    /**
     * CSS class added to root element if mulit select
     */
    get isMultiSelection(): boolean;
    /**
     * CSS class added to root element if mulit click select
     */
    get isMultiClickSelection(): boolean;
    /**
     * Column templates gathered from `ContentChildren`
     * if described in your markup.
     */
    set columnTemplates(val: QueryList<DataTableColumnDirective>);
    /**
     * Returns the column templates.
     */
    get columnTemplates(): QueryList<DataTableColumnDirective>;
    /**
     * Row Detail templates gathered from the ContentChild
     */
    rowDetail: DatatableRowDetailDirective;
    /**
     * Group Header templates gathered from the ContentChild
     */
    groupHeader: DatatableGroupHeaderDirective;
    /**
     * Footer template gathered from the ContentChild
     */
    footer: DatatableFooterDirective;
    /**
     * Reference to the body component for manually
     * invoking functions on the body.
     */
    bodyComponent: DataTableBodyComponent;
    /**
     * Reference to the header component for manually
     * invoking functions on the header.
     *
     * @memberOf DatatableComponent
     */
    headerComponent: DataTableHeaderComponent;
    /**
     * Returns if all rows are selected.
     */
    get allRowsSelected(): boolean;
    element: HTMLElement;
    _innerWidth: number;
    pageSize: number;
    bodyHeight: number;
    rowCount: number;
    rowDiffer: KeyValueDiffer<{}, {}>;
    _offsetX: BehaviorSubject<number>;
    _limit: number | undefined;
    _count: number;
    _offset: number;
    _rows: any[];
    _groupRowsBy: string;
    _internalRows: any[];
    _internalColumns: TableColumn[];
    _columns: TableColumn[];
    _columnTemplates: QueryList<DataTableColumnDirective>;
    _subscriptions: Subscription[];
    constructor(scrollbarHelper: ScrollbarHelper, dimensionsHelper: DimensionsHelper, cd: ChangeDetectorRef, element: ElementRef, differs: KeyValueDiffers, columnChangesService: ColumnChangesService, configuration: INgxDatatableConfig);
    /**
     * Lifecycle hook that is called after data-bound
     * properties of a directive are initialized.
     */
    ngOnInit(): void;
    /**
     * Lifecycle hook that is called after a component's
     * view has been fully initialized.
     */
    ngAfterViewInit(): void;
    /**
     * Lifecycle hook that is called after a component's
     * content has been fully initialized.
     */
    ngAfterContentInit(): void;
    /**
     * This will be used when displaying or selecting rows.
     * when tracking/comparing them, we'll use the value of this fn,
     *
     * (`fn(x) === fn(y)` instead of `x === y`)
     */
    rowIdentity: (x: any) => any;
    /**
     * Translates the templates to the column objects
     */
    translateColumns(val: any): void;
    /**
     * Creates a map with the data grouped by the user choice of grouping index
     *
     * @param originalArray the original array passed via parameter
     * @param groupByIndex  the index of the column to group the data by
     */
    groupArrayBy(originalArray: any, groupBy: any): {
        key: any;
        value: any;
    }[];
    ngDoCheck(): void;
    /**
     * Recalc's the sizes of the grid.
     *
     * Updated automatically on changes to:
     *
     *  - Columns
     *  - Rows
     *  - Paging related
     *
     * Also can be manually invoked or upon window resize.
     */
    recalculate(): void;
    /**
     * Window resize handler to update sizes.
     */
    onWindowResize(): void;
    /**
     * Recalulcates the column widths based on column width
     * distribution mode and scrollbar offsets.
     */
    recalculateColumns(columns?: any[], forceIdx?: number, allowBleed?: boolean): any[] | undefined;
    /**
     * Recalculates the dimensions of the table size.
     * Internally calls the page size and row count calcs too.
     *
     */
    recalculateDims(): void;
    /**
     * Recalculates the pages after a update.
     */
    recalculatePages(): void;
    /**
     * Body triggered a page event.
     */
    onBodyPage({ offset }: any): void;
    /**
     * The body triggered a scroll event.
     */
    onBodyScroll(event: MouseEvent): void;
    /**
     * The footer triggered a page event.
     */
    onFooterPage(event: any): void;
    /**
     * Recalculates the sizes of the page
     */
    calcPageSize(val?: any[]): number;
    /**
     * Calculates the row count.
     */
    calcRowCount(val?: any[]): number;
    /**
     * The header triggered a contextmenu event.
     */
    onColumnContextmenu({ event, column }: any): void;
    /**
     * The body triggered a contextmenu event.
     */
    onRowContextmenu({ event, row }: any): void;
    /**
     * The header triggered a column resize event.
     */
    onColumnResize({ column, newValue }: any): void;
    /**
     * The header triggered a column re-order event.
     */
    onColumnReorder({ column, newValue, prevValue }: any): void;
    /**
     * The header triggered a column sort event.
     */
    onColumnSort(event: any): void;
    /**
     * Toggle all row selection
     */
    onHeaderSelect(event: any): void;
    /**
     * A row was selected from body
     */
    onBodySelect(event: any): void;
    /**
     * A row was expanded or collapsed for tree
     */
    onTreeAction(event: any): void;
    ngOnDestroy(): void;
    /**
     * listen for changes to input bindings of all DataTableColumnDirective and
     * trigger the columnTemplates.changes observable to emit
     */
    private listenForColumnInputChanges;
    private sortInternalRows;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DatatableComponent, [{ skipSelf: true; }, { skipSelf: true; }, null, null, null, null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DatatableComponent, "ngx-datatable", never, { "selected": "selected"; "scrollbarV": "scrollbarV"; "scrollbarH": "scrollbarH"; "rowHeight": "rowHeight"; "columnMode": "columnMode"; "headerHeight": "headerHeight"; "footerHeight": "footerHeight"; "externalPaging": "externalPaging"; "externalSorting": "externalSorting"; "loadingIndicator": "loadingIndicator"; "reorderable": "reorderable"; "swapColumns": "swapColumns"; "sortType": "sortType"; "sorts": "sorts"; "cssClasses": "cssClasses"; "messages": "messages"; "groupExpansionDefault": "groupExpansionDefault"; "selectAllRowsOnPage": "selectAllRowsOnPage"; "virtualization": "virtualization"; "summaryRow": "summaryRow"; "summaryHeight": "summaryHeight"; "summaryPosition": "summaryPosition"; "rowIdentity": "rowIdentity"; "rows": "rows"; "groupedRows": "groupedRows"; "groupRowsBy": "groupRowsBy"; "columns": "columns"; "limit": "limit"; "count": "count"; "offset": "offset"; "targetMarkerTemplate": "targetMarkerTemplate"; "selectionType": "selectionType"; "rowClass": "rowClass"; "selectCheck": "selectCheck"; "displayCheck": "displayCheck"; "trackByProp": "trackByProp"; "treeFromRelation": "treeFromRelation"; "treeToRelation": "treeToRelation"; }, { "scroll": "scroll"; "activate": "activate"; "select": "select"; "sort": "sort"; "page": "page"; "reorder": "reorder"; "resize": "resize"; "tableContextmenu": "tableContextmenu"; "treeAction": "treeAction"; }, ["rowDetail", "groupHeader", "footer", "columnTemplates"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXRhYmxlLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJkYXRhdGFibGUuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIFF1ZXJ5TGlzdCwgQWZ0ZXJWaWV3SW5pdCwgRG9DaGVjaywgS2V5VmFsdWVEaWZmZXJzLCBLZXlWYWx1ZURpZmZlciwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGF0YWJsZUdyb3VwSGVhZGVyRGlyZWN0aXZlIH0gZnJvbSAnLi9ib2R5L2JvZHktZ3JvdXAtaGVhZGVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSU5neERhdGF0YWJsZUNvbmZpZyB9IGZyb20gJy4uL25neC1kYXRhdGFibGUubW9kdWxlJztcbmltcG9ydCB7IFRhYmxlQ29sdW1uIH0gZnJvbSAnLi4vdHlwZXMvdGFibGUtY29sdW1uLnR5cGUnO1xuaW1wb3J0IHsgQ29sdW1uTW9kZSB9IGZyb20gJy4uL3R5cGVzL2NvbHVtbi1tb2RlLnR5cGUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4uL3R5cGVzL3NlbGVjdGlvbi50eXBlJztcbmltcG9ydCB7IFNvcnRUeXBlIH0gZnJvbSAnLi4vdHlwZXMvc29ydC50eXBlJztcbmltcG9ydCB7IENvbnRleHRtZW51VHlwZSB9IGZyb20gJy4uL3R5cGVzL2NvbnRleHRtZW51LnR5cGUnO1xuaW1wb3J0IHsgRGF0YVRhYmxlQ29sdW1uRGlyZWN0aXZlIH0gZnJvbSAnLi9jb2x1bW5zL2NvbHVtbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRGF0YXRhYmxlUm93RGV0YWlsRGlyZWN0aXZlIH0gZnJvbSAnLi9yb3ctZGV0YWlsL3Jvdy1kZXRhaWwuZGlyZWN0aXZlJztcbmltcG9ydCB7IERhdGF0YWJsZUZvb3RlckRpcmVjdGl2ZSB9IGZyb20gJy4vZm9vdGVyL2Zvb3Rlci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRGF0YVRhYmxlQm9keUNvbXBvbmVudCB9IGZyb20gJy4vYm9keS9ib2R5LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2hlYWRlci9oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFNjcm9sbGJhckhlbHBlciB9IGZyb20gJy4uL3NlcnZpY2VzL3Njcm9sbGJhci1oZWxwZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDb2x1bW5DaGFuZ2VzU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2NvbHVtbi1jaGFuZ2VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGltZW5zaW9uc0hlbHBlciB9IGZyb20gJy4uL3NlcnZpY2VzL2RpbWVuc2lvbnMtaGVscGVyLnNlcnZpY2UnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRGF0YXRhYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrLCBBZnRlclZpZXdJbml0IHtcbiAgICBwcml2YXRlIHNjcm9sbGJhckhlbHBlcjtcbiAgICBwcml2YXRlIGRpbWVuc2lvbnNIZWxwZXI7XG4gICAgcHJpdmF0ZSBjZDtcbiAgICBwcml2YXRlIGNvbHVtbkNoYW5nZXNTZXJ2aWNlO1xuICAgIHByaXZhdGUgY29uZmlndXJhdGlvbjtcbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBmb3IgdGhlIHRhcmdldCBtYXJrZXIgb2YgZHJhZyB0YXJnZXQgY29sdW1ucy5cbiAgICAgKi9cbiAgICB0YXJnZXRNYXJrZXJUZW1wbGF0ZTogYW55O1xuICAgIC8qKlxuICAgICAqIFJvd3MgdGhhdCBhcmUgZGlzcGxheWVkIGluIHRoZSB0YWJsZS5cbiAgICAgKi9cbiAgICBzZXQgcm93cyh2YWw6IGFueSk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcm93cy5cbiAgICAgKi9cbiAgICBnZXQgcm93cygpOiBhbnk7XG4gICAgLyoqXG4gICAgICogVGhpcyBhdHRyaWJ1dGUgYWxsb3dzIHRoZSB1c2VyIHRvIHNldCB0aGUgbmFtZSBvZiB0aGUgY29sdW1uIHRvIGdyb3VwIHRoZSBkYXRhIHdpdGhcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBSb3dzQnkodmFsOiBzdHJpbmcpO1xuICAgIGdldCBncm91cFJvd3NCeSgpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhpcyBhdHRyaWJ1dGUgYWxsb3dzIHRoZSB1c2VyIHRvIHNldCBhIGdyb3VwZWQgYXJyYXkgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAgICogIFtcbiAgICAgKiAgICB7Z3JvdXBpZD0xfSBbXG4gICAgICogICAgICB7aWQ9MSBuYW1lPVwidGVzdDFcIn0sXG4gICAgICogICAgICB7aWQ9MiBuYW1lPVwidGVzdDJcIn0sXG4gICAgICogICAgICB7aWQ9MyBuYW1lPVwidGVzdDNcIn1cbiAgICAgKiAgICBdfSxcbiAgICAgKiAgICB7Z3JvdXBpZD0yPltcbiAgICAgKiAgICAgIHtpZD00IG5hbWU9XCJ0ZXN0NFwifSxcbiAgICAgKiAgICAgIHtpZD01IG5hbWU9XCJ0ZXN0NVwifSxcbiAgICAgKiAgICAgIHtpZD02IG5hbWU9XCJ0ZXN0NlwifVxuICAgICAqICAgIF19XG4gICAgICogIF1cbiAgICAgKi9cbiAgICBncm91cGVkUm93czogYW55W107XG4gICAgLyoqXG4gICAgICogQ29sdW1ucyB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgc2V0IGNvbHVtbnModmFsOiBUYWJsZUNvbHVtbltdKTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbnMoKTogVGFibGVDb2x1bW5bXTtcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHJvdyBvYmplY3RzIHRoYXQgc2hvdWxkIGJlXG4gICAgICogcmVwcmVzZW50ZWQgYXMgc2VsZWN0ZWQgaW4gdGhlIGdyaWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZTogYFtdYFxuICAgICAqL1xuICAgIHNlbGVjdGVkOiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgdmVydGljYWwgc2Nyb2xsYmFyc1xuICAgICAqL1xuICAgIHNjcm9sbGJhclY6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGhvcnogc2Nyb2xsYmFyc1xuICAgICAqL1xuICAgIHNjcm9sbGJhckg6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIHJvdyBoZWlnaHQ7IHdoaWNoIGlzIG5lY2Vzc2FyeVxuICAgICAqIHRvIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZvciB0aGUgbGF6eSByZW5kZXJpbmcuXG4gICAgICovXG4gICAgcm93SGVpZ2h0OiBudW1iZXIgfCAnYXV0bycgfCAoKHJvdz86IGFueSkgPT4gbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGNvbHVtbiB3aWR0aCBkaXN0cmlidXRpb24gZm9ybXVsYS5cbiAgICAgKiBFeGFtcGxlOiBmbGV4LCBmb3JjZSwgc3RhbmRhcmRcbiAgICAgKi9cbiAgICBjb2x1bW5Nb2RlOiBDb2x1bW5Nb2RlIHwga2V5b2YgdHlwZW9mIENvbHVtbk1vZGU7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gaGVhZGVyIGhlaWdodCBpbiBwaXhlbHMuXG4gICAgICogUGFzcyBhIGZhbHNleSBmb3Igbm8gaGVhZGVyXG4gICAgICovXG4gICAgaGVhZGVySGVpZ2h0OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gZm9vdGVyIGhlaWdodCBpbiBwaXhlbHMuXG4gICAgICogUGFzcyBmYWxzZXkgZm9yIG5vIGZvb3RlclxuICAgICAqL1xuICAgIGZvb3RlckhlaWdodDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YWJsZSBzaG91bGQgdXNlIGV4dGVybmFsIHBhZ2luZ1xuICAgICAqIG90aGVyd2lzZSBpdHMgYXNzdW1lZCB0aGF0IGFsbCBkYXRhIGlzIHByZWxvYWRlZC5cbiAgICAgKi9cbiAgICBleHRlcm5hbFBhZ2luZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdGFibGUgc2hvdWxkIHVzZSBleHRlcm5hbCBzb3J0aW5nIG9yXG4gICAgICogdGhlIGJ1aWx0LWluIGJhc2ljIHNvcnRpbmcuXG4gICAgICovXG4gICAgZXh0ZXJuYWxTb3J0aW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYWdlIHNpemUgdG8gYmUgc2hvd24uXG4gICAgICogRGVmYXVsdCB2YWx1ZTogYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBzZXQgbGltaXQodmFsOiBudW1iZXIgfCB1bmRlZmluZWQpO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpbWl0LlxuICAgICAqL1xuICAgIGdldCBsaW1pdCgpOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIGNvdW50IG9mIGFsbCByb3dzLlxuICAgICAqIERlZmF1bHQgdmFsdWU6IGAwYFxuICAgICAqL1xuICAgIHNldCBjb3VudCh2YWw6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY291bnQuXG4gICAgICovXG4gICAgZ2V0IGNvdW50KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBvZmZzZXQgKCBwYWdlIC0gMSApIHNob3duLlxuICAgICAqIERlZmF1bHQgdmFsdWU6IGAwYFxuICAgICAqL1xuICAgIHNldCBvZmZzZXQodmFsOiBudW1iZXIpO1xuICAgIGdldCBvZmZzZXQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIGxpbmVhciBsb2FkaW5nIGJhci5cbiAgICAgKiBEZWZhdWx0IHZhbHVlOiBgZmFsc2VgXG4gICAgICovXG4gICAgbG9hZGluZ0luZGljYXRvcjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHJvdyBzZWxlY3Rpb24uIE9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogIC0gYHNpbmdsZWBcbiAgICAgKiAgLSBgbXVsdGlgXG4gICAgICogIC0gYGNoZWNrYm94YFxuICAgICAqICAtIGBtdWx0aUNsaWNrYFxuICAgICAqICAtIGBjZWxsYFxuICAgICAqXG4gICAgICogRm9yIG5vIHNlbGVjdGlvbiBwYXNzIGEgYGZhbHNleWAuXG4gICAgICogRGVmYXVsdCB2YWx1ZTogYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25UeXBlOiBTZWxlY3Rpb25UeXBlO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZS9EaXNhYmxlIGFiaWxpdHkgdG8gcmUtb3JkZXIgY29sdW1uc1xuICAgICAqIGJ5IGRyYWdnaW5nIHRoZW0uXG4gICAgICovXG4gICAgcmVvcmRlcmFibGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3dhcCBjb2x1bW5zIG9uIHJlLW9yZGVyIGNvbHVtbnMgb3JcbiAgICAgKiBtb3ZlIHRoZW0uXG4gICAgICovXG4gICAgc3dhcENvbHVtbnM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2Ygc29ydGluZ1xuICAgICAqL1xuICAgIHNvcnRUeXBlOiBTb3J0VHlwZTtcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBzb3J0ZWQgY29sdW1ucyBieSBwcm9wZXJ0eSBhbmQgdHlwZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlOiBgW11gXG4gICAgICovXG4gICAgc29ydHM6IGFueVtdO1xuICAgIC8qKlxuICAgICAqIENzcyBjbGFzcyBvdmVycmlkZXNcbiAgICAgKi9cbiAgICBjc3NDbGFzc2VzOiBhbnk7XG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBvdmVycmlkZXMgZm9yIGxvY2FsaXphdGlvblxuICAgICAqXG4gICAgICogZW1wdHlNZXNzYWdlICAgICBbZGVmYXVsdF0gPSAnTm8gZGF0YSB0byBkaXNwbGF5J1xuICAgICAqIHRvdGFsTWVzc2FnZSAgICAgW2RlZmF1bHRdID0gJ3RvdGFsJ1xuICAgICAqIHNlbGVjdGVkTWVzc2FnZSAgW2RlZmF1bHRdID0gJ3NlbGVjdGVkJ1xuICAgICAqL1xuICAgIG1lc3NhZ2VzOiBhbnk7XG4gICAgLyoqXG4gICAgICogUm93IHNwZWNpZmljIGNsYXNzZXMuXG4gICAgICogU2ltaWxhciBpbXBsZW1lbnRhdGlvbiB0byBuZ0NsYXNzLlxuICAgICAqXG4gICAgICogIFtyb3dDbGFzc109XCInZmlyc3Qgc2Vjb25kJ1wiXG4gICAgICogIFtyb3dDbGFzc109XCJ7ICdmaXJzdCc6IHRydWUsICdzZWNvbmQnOiB0cnVlLCAndGhpcmQnOiBmYWxzZSB9XCJcbiAgICAgKi9cbiAgICByb3dDbGFzczogYW55O1xuICAgIC8qKlxuICAgICAqIEEgYm9vbGVhbi9mdW5jdGlvbiB5b3UgY2FuIHVzZSB0byBjaGVjayB3aGV0aGVyIHlvdSB3YW50XG4gICAgICogdG8gc2VsZWN0IGEgcGFydGljdWxhciByb3cgYmFzZWQgb24gYSBjcml0ZXJpYS4gRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgIChzZWxlY3Rpb24pID0+IHtcbiAgICAgKiAgICAgIHJldHVybiBzZWxlY3Rpb24gIT09ICdFdGhlbCBQcmljZSc7XG4gICAgICogICAgfVxuICAgICAqL1xuICAgIHNlbGVjdENoZWNrOiBhbnk7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB5b3UgY2FuIHVzZSB0byBjaGVjayB3aGV0aGVyIHlvdSB3YW50XG4gICAgICogdG8gc2hvdyB0aGUgY2hlY2tib3ggZm9yIGEgcGFydGljdWxhciByb3cgYmFzZWQgb24gYSBjcml0ZXJpYS4gRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgIChyb3csIGNvbHVtbiwgdmFsdWUpID0+IHtcbiAgICAgKiAgICAgIHJldHVybiByb3cubmFtZSAhPT0gJ0V0aGVsIFByaWNlJztcbiAgICAgKiAgICB9XG4gICAgICovXG4gICAgZGlzcGxheUNoZWNrOiAocm93OiBhbnksIGNvbHVtbj86IGFueSwgdmFsdWU/OiBhbnkpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIHlvdSBjYW4gdXNlIHRvIHNldCB0aGUgZGV0YXVsdCBiZWhhdmlvdXIgb2Ygcm93cyBhbmQgZ3JvdXBzXG4gICAgICogd2hldGhlciB0aGV5IHdpbGwgc3RhcnQgZXhwYW5kZWQgb3Igbm90LiBJZiBvbW1pdGVkIHRoZSBkZWZhdWx0IGlzIE5PVCBleHBhbmRlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGdyb3VwRXhwYW5zaW9uRGVmYXVsdDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSB0byB3aGljaCB5b3UgY2FuIHVzZSBmb3IgY3VzdG9tIHRyYWNraW5nIG9mIHJvd3MuXG4gICAgICogRXhhbXBsZTogJ25hbWUnXG4gICAgICovXG4gICAgdHJhY2tCeVByb3A6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSB0byB3aGljaCB5b3UgY2FuIHVzZSBmb3IgZGV0ZXJtaW5pbmcgc2VsZWN0IGFsbFxuICAgICAqIHJvd3Mgb24gY3VycmVudCBwYWdlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhdGFibGVDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZWxlY3RBbGxSb3dzT25QYWdlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgZmxhZyBmb3Igcm93IHZpcnR1YWxpemF0aW9uIG9uIC8gb2ZmXG4gICAgICovXG4gICAgdmlydHVhbGl6YXRpb246IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVHJlZSBmcm9tIHJlbGF0aW9uXG4gICAgICovXG4gICAgdHJlZUZyb21SZWxhdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRyZWUgdG8gcmVsYXRpb25cbiAgICAgKi9cbiAgICB0cmVlVG9SZWxhdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEEgZmxhZyBmb3Igc3dpdGNoaW5nIHN1bW1hcnkgcm93IG9uIC8gb2ZmXG4gICAgICovXG4gICAgc3VtbWFyeVJvdzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIGhlaWdodCBvZiBzdW1tYXJ5IHJvd1xuICAgICAqL1xuICAgIHN1bW1hcnlIZWlnaHQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBBIHByb3BlcnR5IGhvbGRzIGEgc3VtbWFyeSByb3cgcG9zaXRpb246IHRvcC9ib3R0b21cbiAgICAgKi9cbiAgICBzdW1tYXJ5UG9zaXRpb246IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBCb2R5IHdhcyBzY3JvbGxlZCB0eXBpY2FsbHkgaW4gYSBgc2Nyb2xsYmFyVjp0cnVlYCBzY2VuYXJpby5cbiAgICAgKi9cbiAgICBzY3JvbGw6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEEgY2VsbCBvciByb3cgd2FzIGZvY3VzZWQgdmlhIGtleWJvYXJkIG9yIG1vdXNlIGNsaWNrLlxuICAgICAqL1xuICAgIGFjdGl2YXRlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBBIGNlbGwgb3Igcm93IHdhcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBzZWxlY3Q6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBzb3J0IHdhcyBpbnZva2VkLlxuICAgICAqL1xuICAgIHNvcnQ6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFRoZSB0YWJsZSB3YXMgcGFnZWQgZWl0aGVyIHRyaWdnZXJlZCBieSB0aGUgcGFnZXIgb3IgdGhlIGJvZHkgc2Nyb2xsLlxuICAgICAqL1xuICAgIHBhZ2U6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIENvbHVtbnMgd2VyZSByZS1vcmRlcmVkLlxuICAgICAqL1xuICAgIHJlb3JkZXI6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIENvbHVtbiB3YXMgcmVzaXplZC5cbiAgICAgKi9cbiAgICByZXNpemU6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZXh0IG1lbnUgd2FzIGludm9rZWQgb24gdGhlIHRhYmxlLlxuICAgICAqIHR5cGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlYWRlciBvciB0aGUgYm9keSB3YXMgY2xpY2tlZC5cbiAgICAgKiBjb250ZW50IGNvbnRhaW5zIGVpdGhlciB0aGUgY29sdW1uIG9yIHRoZSByb3cgdGhhdCB3YXMgY2xpY2tlZC5cbiAgICAgKi9cbiAgICB0YWJsZUNvbnRleHRtZW51OiBFdmVudEVtaXR0ZXI8e1xuICAgICAgICBldmVudDogTW91c2VFdmVudDtcbiAgICAgICAgdHlwZTogQ29udGV4dG1lbnVUeXBlO1xuICAgICAgICBjb250ZW50OiBhbnk7XG4gICAgfT47XG4gICAgLyoqXG4gICAgICogQSByb3cgd2FzIGV4cGFuZGVkIG90IGNvbGxhcHNlZCBmb3IgdHJlZVxuICAgICAqL1xuICAgIHRyZWVBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIENTUyBjbGFzcyBhcHBsaWVkIGlmIHRoZSBoZWFkZXIgaGVpZ2h0IGlmIGZpeGVkIGhlaWdodC5cbiAgICAgKi9cbiAgICBnZXQgaXNGaXhlZEhlYWRlcigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENTUyBjbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWZcbiAgICAgKiB0aGUgcm93IGhlaWdodHMgYXJlIGZpeGVkIGhlaWdodHMuXG4gICAgICovXG4gICAgZ2V0IGlzRml4ZWRSb3coKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDU1MgY2xhc3MgYXBwbGllZCB0byByb290IGVsZW1lbnQgaWZcbiAgICAgKiB2ZXJ0aWNhbCBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNWZXJ0U2Nyb2xsKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ1NTIGNsYXNzIGFwcGxpZWQgdG8gcm9vdCBlbGVtZW50IGlmXG4gICAgICogdmlydHVhbGl6YXRpb24gaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNWaXJ0dWFsaXplZCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENTUyBjbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICAgKiBpZiB0aGUgaG9yemlvbnRhbCBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNIb3JTY3JvbGwoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDU1MgY2xhc3MgYXBwbGllZCB0byByb290IGVsZW1lbnQgaXMgc2VsZWN0YWJsZS5cbiAgICAgKi9cbiAgICBnZXQgaXNTZWxlY3RhYmxlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ1NTIGNsYXNzIGFwcGxpZWQgdG8gcm9vdCBpcyBjaGVja2JveCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGlzQ2hlY2tib3hTZWxlY3Rpb24oKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDU1MgY2xhc3MgYXBwbGllZCB0byByb290IGlmIGNlbGwgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBpc0NlbGxTZWxlY3Rpb24oKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDU1MgY2xhc3MgYXBwbGllZCB0byByb290IGlmIHNpbmdsZSBzZWxlY3QuXG4gICAgICovXG4gICAgZ2V0IGlzU2luZ2xlU2VsZWN0aW9uKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ1NTIGNsYXNzIGFkZGVkIHRvIHJvb3QgZWxlbWVudCBpZiBtdWxpdCBzZWxlY3RcbiAgICAgKi9cbiAgICBnZXQgaXNNdWx0aVNlbGVjdGlvbigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENTUyBjbGFzcyBhZGRlZCB0byByb290IGVsZW1lbnQgaWYgbXVsaXQgY2xpY2sgc2VsZWN0XG4gICAgICovXG4gICAgZ2V0IGlzTXVsdGlDbGlja1NlbGVjdGlvbigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENvbHVtbiB0ZW1wbGF0ZXMgZ2F0aGVyZWQgZnJvbSBgQ29udGVudENoaWxkcmVuYFxuICAgICAqIGlmIGRlc2NyaWJlZCBpbiB5b3VyIG1hcmt1cC5cbiAgICAgKi9cbiAgICBzZXQgY29sdW1uVGVtcGxhdGVzKHZhbDogUXVlcnlMaXN0PERhdGFUYWJsZUNvbHVtbkRpcmVjdGl2ZT4pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbHVtbiB0ZW1wbGF0ZXMuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtblRlbXBsYXRlcygpOiBRdWVyeUxpc3Q8RGF0YVRhYmxlQ29sdW1uRGlyZWN0aXZlPjtcbiAgICAvKipcbiAgICAgKiBSb3cgRGV0YWlsIHRlbXBsYXRlcyBnYXRoZXJlZCBmcm9tIHRoZSBDb250ZW50Q2hpbGRcbiAgICAgKi9cbiAgICByb3dEZXRhaWw6IERhdGF0YWJsZVJvd0RldGFpbERpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBHcm91cCBIZWFkZXIgdGVtcGxhdGVzIGdhdGhlcmVkIGZyb20gdGhlIENvbnRlbnRDaGlsZFxuICAgICAqL1xuICAgIGdyb3VwSGVhZGVyOiBEYXRhdGFibGVHcm91cEhlYWRlckRpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBGb290ZXIgdGVtcGxhdGUgZ2F0aGVyZWQgZnJvbSB0aGUgQ29udGVudENoaWxkXG4gICAgICovXG4gICAgZm9vdGVyOiBEYXRhdGFibGVGb290ZXJEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBib2R5IGNvbXBvbmVudCBmb3IgbWFudWFsbHlcbiAgICAgKiBpbnZva2luZyBmdW5jdGlvbnMgb24gdGhlIGJvZHkuXG4gICAgICovXG4gICAgYm9keUNvbXBvbmVudDogRGF0YVRhYmxlQm9keUNvbXBvbmVudDtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGhlYWRlciBjb21wb25lbnQgZm9yIG1hbnVhbGx5XG4gICAgICogaW52b2tpbmcgZnVuY3Rpb25zIG9uIHRoZSBoZWFkZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YXRhYmxlQ29tcG9uZW50XG4gICAgICovXG4gICAgaGVhZGVyQ29tcG9uZW50OiBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQ7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBhbGwgcm93cyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgZ2V0IGFsbFJvd3NTZWxlY3RlZCgpOiBib29sZWFuO1xuICAgIGVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIF9pbm5lcldpZHRoOiBudW1iZXI7XG4gICAgcGFnZVNpemU6IG51bWJlcjtcbiAgICBib2R5SGVpZ2h0OiBudW1iZXI7XG4gICAgcm93Q291bnQ6IG51bWJlcjtcbiAgICByb3dEaWZmZXI6IEtleVZhbHVlRGlmZmVyPHt9LCB7fT47XG4gICAgX29mZnNldFg6IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+O1xuICAgIF9saW1pdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIF9jb3VudDogbnVtYmVyO1xuICAgIF9vZmZzZXQ6IG51bWJlcjtcbiAgICBfcm93czogYW55W107XG4gICAgX2dyb3VwUm93c0J5OiBzdHJpbmc7XG4gICAgX2ludGVybmFsUm93czogYW55W107XG4gICAgX2ludGVybmFsQ29sdW1uczogVGFibGVDb2x1bW5bXTtcbiAgICBfY29sdW1uczogVGFibGVDb2x1bW5bXTtcbiAgICBfY29sdW1uVGVtcGxhdGVzOiBRdWVyeUxpc3Q8RGF0YVRhYmxlQ29sdW1uRGlyZWN0aXZlPjtcbiAgICBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW107XG4gICAgY29uc3RydWN0b3Ioc2Nyb2xsYmFySGVscGVyOiBTY3JvbGxiYXJIZWxwZXIsIGRpbWVuc2lvbnNIZWxwZXI6IERpbWVuc2lvbnNIZWxwZXIsIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudDogRWxlbWVudFJlZiwgZGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjb2x1bW5DaGFuZ2VzU2VydmljZTogQ29sdW1uQ2hhbmdlc1NlcnZpY2UsIGNvbmZpZ3VyYXRpb246IElOZ3hEYXRhdGFibGVDb25maWcpO1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGRhdGEtYm91bmRcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGEgZGlyZWN0aXZlIGFyZSBpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50J3NcbiAgICAgKiB2aWV3IGhhcyBiZWVuIGZ1bGx5IGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50J3NcbiAgICAgKiBjb250ZW50IGhhcyBiZWVuIGZ1bGx5IGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBiZSB1c2VkIHdoZW4gZGlzcGxheWluZyBvciBzZWxlY3Rpbmcgcm93cy5cbiAgICAgKiB3aGVuIHRyYWNraW5nL2NvbXBhcmluZyB0aGVtLCB3ZSdsbCB1c2UgdGhlIHZhbHVlIG9mIHRoaXMgZm4sXG4gICAgICpcbiAgICAgKiAoYGZuKHgpID09PSBmbih5KWAgaW5zdGVhZCBvZiBgeCA9PT0geWApXG4gICAgICovXG4gICAgcm93SWRlbnRpdHk6ICh4OiBhbnkpID0+IGFueTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSB0ZW1wbGF0ZXMgdG8gdGhlIGNvbHVtbiBvYmplY3RzXG4gICAgICovXG4gICAgdHJhbnNsYXRlQ29sdW1ucyh2YWw6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCB3aXRoIHRoZSBkYXRhIGdyb3VwZWQgYnkgdGhlIHVzZXIgY2hvaWNlIG9mIGdyb3VwaW5nIGluZGV4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxBcnJheSB0aGUgb3JpZ2luYWwgYXJyYXkgcGFzc2VkIHZpYSBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0gZ3JvdXBCeUluZGV4ICB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB0byBncm91cCB0aGUgZGF0YSBieVxuICAgICAqL1xuICAgIGdyb3VwQXJyYXlCeShvcmlnaW5hbEFycmF5OiBhbnksIGdyb3VwQnk6IGFueSk6IHtcbiAgICAgICAga2V5OiBhbnk7XG4gICAgICAgIHZhbHVlOiBhbnk7XG4gICAgfVtdO1xuICAgIG5nRG9DaGVjaygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlY2FsYydzIHRoZSBzaXplcyBvZiB0aGUgZ3JpZC5cbiAgICAgKlxuICAgICAqIFVwZGF0ZWQgYXV0b21hdGljYWxseSBvbiBjaGFuZ2VzIHRvOlxuICAgICAqXG4gICAgICogIC0gQ29sdW1uc1xuICAgICAqICAtIFJvd3NcbiAgICAgKiAgLSBQYWdpbmcgcmVsYXRlZFxuICAgICAqXG4gICAgICogQWxzbyBjYW4gYmUgbWFudWFsbHkgaW52b2tlZCBvciB1cG9uIHdpbmRvdyByZXNpemUuXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBXaW5kb3cgcmVzaXplIGhhbmRsZXIgdG8gdXBkYXRlIHNpemVzLlxuICAgICAqL1xuICAgIG9uV2luZG93UmVzaXplKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVjYWx1bGNhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIGJhc2VkIG9uIGNvbHVtbiB3aWR0aFxuICAgICAqIGRpc3RyaWJ1dGlvbiBtb2RlIGFuZCBzY3JvbGxiYXIgb2Zmc2V0cy5cbiAgICAgKi9cbiAgICByZWNhbGN1bGF0ZUNvbHVtbnMoY29sdW1ucz86IGFueVtdLCBmb3JjZUlkeD86IG51bWJlciwgYWxsb3dCbGVlZD86IGJvb2xlYW4pOiBhbnlbXSB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRhYmxlIHNpemUuXG4gICAgICogSW50ZXJuYWxseSBjYWxscyB0aGUgcGFnZSBzaXplIGFuZCByb3cgY291bnQgY2FsY3MgdG9vLlxuICAgICAqXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGVEaW1zKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSBwYWdlcyBhZnRlciBhIHVwZGF0ZS5cbiAgICAgKi9cbiAgICByZWNhbGN1bGF0ZVBhZ2VzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQm9keSB0cmlnZ2VyZWQgYSBwYWdlIGV2ZW50LlxuICAgICAqL1xuICAgIG9uQm9keVBhZ2UoeyBvZmZzZXQgfTogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSB0cmlnZ2VyZWQgYSBzY3JvbGwgZXZlbnQuXG4gICAgICovXG4gICAgb25Cb2R5U2Nyb2xsKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9vdGVyIHRyaWdnZXJlZCBhIHBhZ2UgZXZlbnQuXG4gICAgICovXG4gICAgb25Gb290ZXJQYWdlKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgc2l6ZXMgb2YgdGhlIHBhZ2VcbiAgICAgKi9cbiAgICBjYWxjUGFnZVNpemUodmFsPzogYW55W10pOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcm93IGNvdW50LlxuICAgICAqL1xuICAgIGNhbGNSb3dDb3VudCh2YWw/OiBhbnlbXSk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVhZGVyIHRyaWdnZXJlZCBhIGNvbnRleHRtZW51IGV2ZW50LlxuICAgICAqL1xuICAgIG9uQ29sdW1uQ29udGV4dG1lbnUoeyBldmVudCwgY29sdW1uIH06IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgdHJpZ2dlcmVkIGEgY29udGV4dG1lbnUgZXZlbnQuXG4gICAgICovXG4gICAgb25Sb3dDb250ZXh0bWVudSh7IGV2ZW50LCByb3cgfTogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVhZGVyIHRyaWdnZXJlZCBhIGNvbHVtbiByZXNpemUgZXZlbnQuXG4gICAgICovXG4gICAgb25Db2x1bW5SZXNpemUoeyBjb2x1bW4sIG5ld1ZhbHVlIH06IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIGhlYWRlciB0cmlnZ2VyZWQgYSBjb2x1bW4gcmUtb3JkZXIgZXZlbnQuXG4gICAgICovXG4gICAgb25Db2x1bW5SZW9yZGVyKHsgY29sdW1uLCBuZXdWYWx1ZSwgcHJldlZhbHVlIH06IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIGhlYWRlciB0cmlnZ2VyZWQgYSBjb2x1bW4gc29ydCBldmVudC5cbiAgICAgKi9cbiAgICBvbkNvbHVtblNvcnQoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGFsbCByb3cgc2VsZWN0aW9uXG4gICAgICovXG4gICAgb25IZWFkZXJTZWxlY3QoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQSByb3cgd2FzIHNlbGVjdGVkIGZyb20gYm9keVxuICAgICAqL1xuICAgIG9uQm9keVNlbGVjdChldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBIHJvdyB3YXMgZXhwYW5kZWQgb3IgY29sbGFwc2VkIGZvciB0cmVlXG4gICAgICovXG4gICAgb25UcmVlQWN0aW9uKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogbGlzdGVuIGZvciBjaGFuZ2VzIHRvIGlucHV0IGJpbmRpbmdzIG9mIGFsbCBEYXRhVGFibGVDb2x1bW5EaXJlY3RpdmUgYW5kXG4gICAgICogdHJpZ2dlciB0aGUgY29sdW1uVGVtcGxhdGVzLmNoYW5nZXMgb2JzZXJ2YWJsZSB0byBlbWl0XG4gICAgICovXG4gICAgcHJpdmF0ZSBsaXN0ZW5Gb3JDb2x1bW5JbnB1dENoYW5nZXM7XG4gICAgcHJpdmF0ZSBzb3J0SW50ZXJuYWxSb3dzO1xufVxuIl19